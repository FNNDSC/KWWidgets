/*=========================================================================

  Module:    $RCSfile: vtkKWFileListTable.cxx,v $

  Copyright (c) Kitware, Inc.
  All rights reserved.
  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.

     This software is distributed WITHOUT ANY WARRANTY; without even
     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
     PURPOSE.  See the above copyright notice for more information.

=========================================================================*/

#include "vtkKWFileListTable.h"

#include "vtkKWApplication.h"
#include "vtkKWOptions.h"
#include "vtkKWEntry.h"
#include "vtkKWEntryWithLabel.h"
#include "vtkKWIcon.h"
#include "vtkKWFileBrowserUtilities.h"
#include "vtkKWInternationalization.h"
#include "vtkKWLabel.h"
#include "vtkMath.h"
#include "vtkKWMenu.h"
#include "vtkKWMessageDialog.h"
#include "vtkKWMultiColumnList.h"
#include "vtkKWMultiColumnListWithScrollbars.h"
#include "vtkKWPushButton.h"
#include "vtkKWScrollbar.h"
#include "vtkKWSimpleEntryDialog.h"
#include "vtkKWTkUtilities.h"

#include "vtkDirectory.h"
#include "vtkObjectFactory.h"
#include <vtksys/SystemTools.hxx>
#include <vtksys/stl/string>
#include <vtksys/Glob.hxx>
#include <sys/stat.h>
#include <time.h>
#include <locale.h>

//----------------------------------------------------------------------------
vtkStandardNewMacro( vtkKWFileListTable );
vtkCxxRevisionMacro(vtkKWFileListTable, "$Revision: 1.1 $");

/* 
 * This part was generated by ImageConvert from image:
 *    folderxp16x13.png (zlib, base64) (image file)
 */
#define image_folder_width          16
#define image_folder_height         13
#define image_folder_pixel_size     4
#define image_folder_length         456

static unsigned char image_folder[] = 
  "eNpjYICAMzON/5+eYfT/5DSD/8en6P0HCikCMRcDEQCkFx0c6tcEmWEBNYMRC0bTOxMN//"
  "+/t0vl/652xf/bW+T+b22S+b+5Qer/hlpxmNs4QfpBbv7/feL//1/6MDEWsK5a9D8zM3Mp"
  "UKsSyB0g//5/3fr//7OG/0cn6WDFB3rV/+/pVP6/o1X+/5ZGabA7QBjkDlBY/X9QBVZHFA"
  "DaAwKLC7jA7gDru5L3HxIOMwniH0fjwfSCXHaQ/imgcP5/Jg0cd2A1oLDAg9/vCQOrm5fN"
  "CtI/FeQ3kH6I+2dCwgIPfrbZF6xuTiYzWD8ojkD69/eoQfQDwwIfvrPSGaxuVjojWD8ofk"
  "H6QWEL1g8MC3z48gIrsLqZaQxg/4PiADltgOJ3dYXQ/xWl/P+XFvGAwxkUViD/gtwMshek"
  "l4mJaStQfx00fVqA2CD3kIBBei0AqWHo/Q==";

//----------------------------------------------------------------------------
class vtkKWFileListTableInternals
{
public:
  
  vtkKWFileListTableInternals()
  {
    SortedOrder = false;
    Num_thousands_sep = '\0';
  }
  
  vtksys_stl::string FolderImage;
  bool SortedOrder; //true, increasing; false, decreasing
  char Num_thousands_sep;
};

//----------------------------------------------------------------------------
vtkKWFileListTable::vtkKWFileListTable()
{  
  this->Internals = new vtkKWFileListTableInternals;
  this->FileList  = vtkKWMultiColumnListWithScrollbars::New();
  this->FileSelectedCommand = NULL;
  this->FileDoubleClickedCommand = NULL;
  this->FileRemovedCommand = NULL;
  this->ParentDirectory = NULL;
  this->SelectedFile = NULL;
  this->FileRenamedCommand = NULL;
  this->FolderCreatedCommand = NULL;
  this->ContextMenu = NULL;
}

//----------------------------------------------------------------------------
vtkKWFileListTable::~vtkKWFileListTable()
{
  if (this->FileSelectedCommand)
    { 
    delete [] this->FileSelectedCommand;
    this->FileSelectedCommand = NULL;
    }
  if (this->FileDoubleClickedCommand )
    {
    delete [] this->FileDoubleClickedCommand;
    this->FileDoubleClickedCommand = NULL;
    }    
  if (this->FileRemovedCommand)
    {
    delete [] this->FileRemovedCommand;
    this->FileRemovedCommand = NULL;
    }
  if (this->FileRenamedCommand)
    {
    delete [] this->FileRenamedCommand;
    this->FileRenamedCommand = NULL;
    }
  if (this->FolderCreatedCommand)
    {
    delete [] this->FolderCreatedCommand;
    this->FolderCreatedCommand = NULL;
    }
  this->FileList->Delete();
  if (this->ContextMenu)
    {
    this->ContextMenu->Delete();
    this->ContextMenu = NULL;
    }
  if (this->ParentDirectory)
    {
    this->SetParentDirectory(NULL);
    }
  if (this->SelectedFile)
    {
    delete [] this->SelectedFile;
    this->SelectedFile = NULL;
    }
  // Clear internals list
  if (this->Internals)
    {      
    delete this->Internals;
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::CreateWidget()
{
  // Check if already created
  if (this->IsCreated())
    {
    vtkErrorMacro(<< this->GetClassName() << " already created");
    return;
    }

  // Call the superclass to create the whole widget
  this->Superclass::CreateWidget();
  
  this->CreateFileListTable();
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::CreateFileListTable()
{
  this->FileList->SetParent(this);
  this->FileList->Create();
  this->FileList->GetVerticalScrollbar()->
    SetConfigurationOptionAsInt("-takefocus", 0);
  this->FileList->GetHorizontalScrollbar()->
    SetConfigurationOptionAsInt("-takefocus", 0);

  vtkKWMultiColumnList *filelist = this->FileList->GetWidget();
  filelist->SetBackgroundColor(1, 1, 1);

  // Setup the image for the tree node
  this->Internals->FolderImage = 
    filelist->GetWidgetName();
  this->Internals->FolderImage.append("_0");
  if (!vtkKWTkUtilities::UpdatePhoto(
    this->GetApplication(),
    this->Internals->FolderImage.c_str(),
    image_folder, 
    image_folder_width, 
    image_folder_height, 
    image_folder_pixel_size,
    image_folder_length))
    {
    vtkWarningMacro(
      << "Error updating Tk photo " 
      << this->Internals->FolderImage.c_str());
    }
    
  // Setup the file list aspects
  filelist->MovableColumnsOn();
  filelist->SetWidth(0);
  //filelist->ExportSelectionOn();
  int col_index = filelist->AddColumn("Name");
  col_index = filelist->AddColumn("Size");
  col_index = filelist->AddColumn("Modified time");
  col_index = filelist->AddColumn("HiddenSort");
  for(int i=0;i<filelist->GetNumberOfColumns(); i++)
    {
    filelist->SetColumnEditable(i, 0);
    }
  filelist->ColumnVisibilityOff(3);
  filelist->SetColumnSortModeToInteger(3);
  filelist->SetSortedColumnBackgroundColor(0.96, 0.96, 0.96);
  filelist->SetColumnSeparatorsVisibility(0);
  filelist->SetStripeHeight(0);
  filelist->SetColumnAlignmentToRight(1);
  filelist->SetColumnAlignmentToRight(2);
  filelist->ColorSortedColumnOn();
  filelist->ClearStripeBackgroundColor();
  filelist->SetRowSpacing(0);
  
  filelist->SetSelectionCommand(this, 
    "SelectedFileChangedCallback");
  filelist->SetColumnFormatCommand(0, this, 
    "GetRealNameStringCallback");
  filelist->SetColumnFormatCommand(1, this, 
    "GetFormatSizeStringCallback");
  filelist->SetColumnSortModeToInteger(1);
  filelist->SetColumnFormatCommand(2, this, 
    "GetFormatTimeStringCallback");
  // Set the sort mode of the Name column to 'dictionary'
  // so that sorting will be case insensitive;
  filelist->SetColumnSortMode(0, vtkKWMultiColumnList::SortModeDictionary);
  // Set the sort mode of the Time column to 'command';
  filelist->SetColumnSortMode(2, vtkKWMultiColumnList::SortModeCommand);
  filelist->SetColumnSortCommand(2, this, 
    "SortTimeCallback");
  filelist->SetBinding("<Delete>", this, 
    "RemoveSelectedFileCallback");
  filelist->SetUneditableCellDoubleClickCommand(this, 
    "FileDoubleClickCallback");
  filelist->SetRightClickCommand(this, 
    "FileRightClickCallback");

  // Change the Home/End/Prior/Next keypress behavior to be like win explorer

  filelist->SetBinding("<Home>", this, "KeyHomeEndNavigationCallback Home");
  filelist->SetBinding("<End>", this, "KeyHomeEndNavigationCallback End");
  filelist->SetBinding("<Prior>", this, 
    "KeyPriorNextNavigationCallback  %W %x %y %X %Y Prior");
  filelist->SetBinding("<Next>", this, 
    "KeyPriorNextNavigationCallback  %W %x %y %X %Y Next");
  
  filelist->SetBinding("<Return>", this, "FileDoubleClickCallback");
  filelist->SetBinding("<F2>", this, "RenameCallback");
  filelist->SetBinding("<FocusIn>", this, "FocusInCallback");

  this->Script(
    "pack %s -side top -fill both -expand true -padx 1 -pady 1",
    this->FileList->GetWidgetName());
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::AddBindingToInternalWidget(const char* kwevent,
    vtkObject *obj, const char* method)
{
  this->FileList->GetWidget()->AddBinding(kwevent, obj, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetSelectionMode(int arg)
{
  if (arg != this->FileList->GetWidget()->GetSelectionMode())
    {
    this->FileList->GetWidget()->SetSelectionMode(arg);
    }
}

void vtkKWFileListTable::SetSelectionModeToSingle() 
{ 
  this->SetSelectionMode(vtkKWOptions::SelectionModeSingle); 
};
void vtkKWFileListTable::SetSelectionModeToBrowse() 
{ 
  this->SetSelectionMode(vtkKWOptions::SelectionModeBrowse); 
};
void vtkKWFileListTable::SetSelectionModeToMultiple() 
{ 
  this->SetSelectionMode(vtkKWOptions::SelectionModeMultiple); 
};
void vtkKWFileListTable::SetSelectionModeToExtended() 
{ 
  this->SetSelectionMode(vtkKWOptions::SelectionModeExtended); 
};

//----------------------------------------------------------------------------
void vtkKWFileListTable::Focus()
{
  if (this->IsCreated())
    {
    // force the window focus to this table
    this->FileList->GetWidget()->Focus();
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::GetSelectionBackgroundColor(
  double *r, double *g, double *b)
{
  this->FileList->GetWidget()->GetSelectionBackgroundColor(r, g, b);
}

//----------------------------------------------------------------------------
double* vtkKWFileListTable::GetSelectionBackgroundColor()
{
  return this->FileList->GetWidget()->GetSelectionBackgroundColor();
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetSelectionBackgroundColor(
  double r, double g, double b)
{
  this->FileList->GetWidget()->SetSelectionBackgroundColor(r, g, b);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::GetSelectionForegroundColor(
  double *r, double *g, double *b)
{
  this->FileList->GetWidget()->GetSelectionForegroundColor(r, g, b);
}

//----------------------------------------------------------------------------
double* vtkKWFileListTable::GetSelectionForegroundColor()
{
  return this->FileList->GetWidget()->GetSelectionForegroundColor();
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetSelectionForegroundColor(double r, double g, double b)
{
  this->FileList->GetWidget()->SetSelectionForegroundColor(r, g, b);
}

//----------------------------------------------------------------------------
const char* vtkKWFileListTable::GetCellText(int row, int col)
{
  if (this->FileList->IsCreated())
    {
    if (col == 0)
      {
      return this->GetRealNameStringCallback(
        this->FileList->GetWidget()->GetCellText(row, col));
      }
    else if (col == 1)
      {
      return this->GetFormatSizeStringCallback(
        this->FileList->GetWidget()->GetCellText(row, col));
      }
    else if (col == 2)
      {
      return this->GetFormatTimeStringCallback(
        this->FileList->GetWidget()->GetCellText(row, col));
      }
    }
    
  return NULL;
}

//----------------------------------------------------------------------------
int vtkKWFileListTable::GetNumberOfSelectedFiles()
{
  return this->FileList->GetWidget()->GetNumberOfSelectedRows();
}

//----------------------------------------------------------------------------
const char *vtkKWFileListTable::GetNthSelectedFile(int i)
{
  int selrows = 
    this->FileList->GetWidget()->GetNumberOfSelectedRows();
  if (i < 0 || i >= selrows)
    {
    vtkErrorMacro(<< this->GetClassName()
                  << " index for GetNthSelectedFile is out of range");
    return NULL;
    }
  if(selrows > 0)
    {
    int *indices = new int [selrows];
    int nb_selected_rows = this->FileList->GetWidget()->
                           GetSelectedRows(indices);
    int row = indices[i];
    delete [] indices;
    return GetRowFileName(row);
    }
  else
    {
    return NULL;
    }
}

//----------------------------------------------------------------------------
char* vtkKWFileListTable::GetRowFileName(int row)
{
  vtksys_stl::string fullname = this->GetParentDirectory();
  if (!fullname.empty())
    {
    vtksys_stl::string filename = this->GetCellText(row, 0);
    if (strcmp(fullname.c_str(), KWFileBrowser_UNIX_ROOT_DIRECTORY)!=0)
      {
      fullname += KWFileBrowser_PATH_SEPARATOR;
      }
    fullname.append(filename.c_str());
    static char buffer[512];
    strcpy(buffer, fullname.c_str()); 
    return buffer;
    }
  else
    {
    return NULL;
    }
}

//----------------------------------------------------------------------------
void  vtkKWFileListTable::SetSelectedFile(
  const char* arg)
{
  if (this->SelectedFile == NULL && arg == NULL) 
    { 
    return;
    }

  if (this->SelectedFile && arg && 
    (!strcmp(this->SelectedFile, arg))) 
    { 
    return;
    }

  if (this->SelectedFile) 
    { 
    delete [] this->SelectedFile; 
    }

  if (arg)
    {
    this->SelectedFile = new char[strlen(arg)+1];
    strcpy(this->SelectedFile,arg);
    }
   else
    {
    this->SelectedFile = NULL;
    }

  this->Modified();

  this->InvokeFileSelectedCommand(this->SelectedFile);
}

//----------------------------------------------------------------------------
int vtkKWFileListTable::ShowFileList(
  const char* inpath, const char* filepattern,
  const char* fileextensions)
{
  if (!this->IsCreated() || !inpath || !(*inpath))
    {
    return 0;
    }
  vtkKWTkUtilities::SetTopLevelMouseCursor(this, "watch");

  // Check if we need use pattern filters
  bool bUsePattern = false;
  vtkstd::vector<vtkstd::string> filenames;
  if (filepattern && *filepattern)
    {
    bUsePattern = true;
    vtksys_stl::string fullPattern = filepattern;
    vtksys::Glob glob;
    glob.RecurseOff();

    vtkstd::vector<vtkstd::string> components;
    vtksys::SystemTools::SplitPath(fullPattern.c_str(), components);
    // If Pattern is a relative path, prepend with Directory
    if (components[0] == "")
      {
      components.insert(components.begin(), this->ParentDirectory);
      fullPattern = vtksys::SystemTools::JoinPath(components);
      }

    if (!glob.FindFiles(fullPattern.c_str()))
      {
      vtkErrorMacro(<< "FindFileNames: Glob action failed for \"" <<
                    fullPattern.c_str() << "\"");
      return 0;
      }
    // copy the filenames from glob
    filenames = glob.GetFiles();
    }
     
  // Check if we need use extension filters
  bool bUseExt = false;  
  vtksys_stl::vector<vtksys_stl::string> fileexts;
  vtksys_stl::vector<vtksys_stl::string>::iterator it;

  // The pattern filter should overwrite extension filter.
  if (!bUsePattern)
    {
    if (fileextensions && *fileextensions)
      {
      vtksys::SystemTools::Split(fileextensions, fileexts, ',');
      }
    if (fileexts.size()>0)
      {
      bUseExt = true;
      for(it = fileexts.begin(); it != fileexts.end(); it++)
        {
        if (strcmp((*it).c_str(), ".*")==0)
          {
          bUseExt = false;
          break;
          }
        }
      }
    }
    
  vtksys_stl::string parentpath = 
    vtksys::SystemTools::DuplicateString(inpath);
  vtkKWMultiColumnList *filelist = this->FileList->GetWidget();
  
#if defined (_DEBUG)  
  cout << "-----------------UpdateFileList: " << parentpath << endl;
  clock_t start = clock();
#endif

  vtkDirectory *dir = vtkDirectory::New();
  if (!dir->Open(parentpath.c_str()))
    {
    dir->Delete();
    this->SetParentDirectory(NULL);
    this->FileList->GetWidget()->DeleteAllRows();
    vtkKWTkUtilities::SetTopLevelMouseCursor(this, NULL);
    return 0;
    }
      
  int num_files = dir->GetNumberOfFiles();
  
#if defined (_DEBUG)  
  double durationopen = (double)(clock() - start) / CLOCKS_PER_SEC;
  cout << "Dir open time: " << durationopen << endl;
  start = clock();
#endif

  // Have these two flags so that we do not need to do strcmp
  // for every file in the directory
  bool dotfound=false, dotdotfound=false;
  
  ostrstream tk_filecmd, tk_foldercmd;
  const char *listname = filelist->GetWidgetName();

  int folder_index = 0; 
  vtksys_stl::string filename = "",fullname = "";
  const char* image_name = this->Internals->FolderImage.c_str();
   
  struct stat fs;
  this->SetParentDirectory(parentpath.c_str());
  if (strcmp(parentpath.c_str(), KWFileBrowser_UNIX_ROOT_DIRECTORY)!=0)
    {
    parentpath += KWFileBrowser_PATH_SEPARATOR;
    }
      
  vtksys_stl::string::size_type dot_pos;
// The purpose of branching out for windows and *nix here is to try
// to improve performance for big directories in the sacrifice of 
// coding efficiency.
#if defined( _WIN32 )
  for (int i = 0; i < num_files; i++)
    {
    filename = dir->GetFile(i);
    //skip . and ..
    if (!dotfound || !dotdotfound)
      { 
      if (strcmp(filename.c_str(), ".")==0)
        {
        dotfound=true;
        continue;
        }
      else if (strcmp(filename.c_str(), "..")==0)
        {
        dotdotfound = true;
        continue;
        }
      }
      
    fullname = parentpath;
    fullname += filename;
    if (stat(fullname.c_str(), &fs) != 0)
      {
      continue;
      }
  // for files, prepend 1 to name; add 1 to size; prepend + to time;
  // for folders, prepend 0 to name; size alway 0; prepend - to time;
  // so that during sorting, we can always keep folder and files separated.
  if (!(fs.st_mode & _S_IFDIR)) 
    {
    if (bUsePattern)
      {
      for(it=filenames.begin();it != filenames.end(); it++)
        {
        if (strcmp(vtksys::SystemTools::GetFilenameName((*it).c_str()).c_str(),
          filename.c_str())==0)
          {
          filenames.erase(it);
          tk_filecmd << listname << " insert end {\"b" 
                     << filename.c_str() << "\"" << " " << ++fs.st_size 
                     << " +" << fs.st_mtime << " 1}" << endl;
          break;
          }
        }
      }
    else if (bUseExt)
      {
      for(it = fileexts.begin(); it != fileexts.end(); it++)
        {
          dot_pos = filename.rfind(".");
          if (dot_pos != vtksys_stl::string::npos &&
            strcmp((*it).c_str(), filename.substr(dot_pos).c_str())==0)
            {
            // The ++size is for sorting 0-byte files (become 1 byte) 
            // with folders (size 0)
            tk_filecmd << listname << " insert end {\"b" 
                       << filename.c_str() << "\"" << " " << ++fs.st_size 
                       << " +" << fs.st_mtime << " 1}" << endl;
            break;
            }
        }
      }
    else
      {
      // The ++size is for sorting 0-byte files (become 1 byte) 
      // with folders (size 0)
      tk_filecmd << listname << " insert end {\"b" 
                 << filename.c_str() << "\"" << " " << ++fs.st_size 
                 << " +" << fs.st_mtime << " 1}" << endl;
      }
    }
  else
    {
    tk_foldercmd << listname << " insert end {\"a" 
                 << filename.c_str() << "\" 0 -" 
                 << fs.st_mtime << " 0}" << endl;
    // Add folder image to this cell
    tk_foldercmd << "tablelist::doCellConfig "    
       << folder_index << " " << 0  << " " 
       << listname << " -image " << "{" 
       << image_name << "}" << endl;
    folder_index++;
    }//end if (isfolder)
  }//end for
#else
  for (int i = 0; i < num_files; i++)
    {
    filename = dir->GetFile(i);
    //skip . and ..
    if (!dotfound || !dotdotfound)
      { 
      if (strcmp(filename.c_str(), ".")==0)
        {
        dotfound=true;
        continue;
        }
      else if (strcmp(filename.c_str(), "..")==0)
        {
        dotdotfound = true;
        continue;
        }
      }
      
    fullname = parentpath;
    fullname += filename;
    if (stat(fullname.c_str(), &fs) != 0)
      {
      continue;
      }
  // for files, prepend 1 to name; add 1 to size; prepend + to time;
  // for folders, prepend 0 to name; size alway 0; prepend - to time;
  // so that during sorting, we can always keep folder and files separated.
  if (!S_ISDIR(fs.st_mode)) 
    {
    if (bUsePattern)
      {
      for(it=filenames.begin();it != filenames.end(); it++)
        {
        if (strcmp(vtksys::SystemTools::GetFilenameName((*it).c_str()).c_str(),
          filename.c_str())==0)
          {
          filenames.erase(it);
          tk_filecmd << listname << " insert end {\"b" 
                     << filename.c_str() << "\"" << " " << ++fs.st_size 
                     << " +" << fs.st_mtime << " 1}" << endl;
          break;
          }
        }
      }
    else if (bUseExt)
      {
      for(it = fileexts.begin(); it != fileexts.end(); it++)
        {
          dot_pos = filename.rfind(".");
          if (dot_pos != vtksys_stl::string::npos &&
            strcmp((*it).c_str(), filename.substr(dot_pos).c_str())==0)
            {
            // The ++size is for sorting 0-byte files (become 1 byte) 
            // with folders (size 0)
            tk_filecmd << listname << " insert end {\"b" 
                       << filename.c_str() << "\"" << " " << ++fs.st_size 
                       << " +" << fs.st_mtime << " 1}" << endl;
            break;
            }
        }
      }
    else
      {
      // The ++size is for sorting 0-byte files (become 1 byte) 
      // with folders (size 0)
      tk_filecmd << listname << " insert end {\"b" 
                 << filename.c_str() << "\"" << " " << ++fs.st_size 
                 << " +" << fs.st_mtime << " 1}" << endl;
      }
    }
  else
    {
    tk_foldercmd << listname << " insert end {\"a" 
                 << filename.c_str() << "\" 0 -" 
                 << fs.st_mtime << " 0}" << endl;
    // Add folder image to this cell
    tk_foldercmd << "tablelist::doCellConfig "    
       << folder_index << " " << 0  << " " 
       << listname << " -image " << "{" 
       << image_name << "}" << endl;
    folder_index++;
    }//end if (isfolder)
  }//end for
#endif
     
#if defined (_DEBUG)  
  durationopen = (double)(clock() - start) / CLOCKS_PER_SEC;
  cout << "Creat Script time: " << durationopen << endl;
  start = clock();
#endif
  
  dir->Delete();
  
  filelist->DeleteAllRows();
  //Add the folder first 
  if (tk_foldercmd.rdbuf() && tk_foldercmd.rdbuf()->pcount() > 0)
    {
    tk_foldercmd << ends;
    this->Script(tk_foldercmd.str());
    }
  //Now add the file entries
  if (tk_filecmd.rdbuf() && tk_filecmd.rdbuf()->pcount() > 0)
    {
    tk_filecmd << ends;
    this->Script(tk_filecmd.str());
    }
    
  tk_foldercmd.rdbuf()->freeze(0);
  tk_filecmd.rdbuf()->freeze(0);
  
#if defined (_DEBUG)  
  durationopen = (double)(clock() - start) / CLOCKS_PER_SEC;
  cout << "Run script time: " << durationopen << endl;
#endif

  int sortcol = filelist->GetLastSortedColumn();
  if (sortcol >=0)
    {
    filelist->SortByColumn(sortcol, filelist->GetLastSortedOrder());
    }
  vtkKWTkUtilities::SetTopLevelMouseCursor(this, NULL);
  
  return 1;
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SelectFile(const char* filename)
{
  if (!filename || !(*filename) ||
    !vtksys::SystemTools::FileExists(filename))
    {
    return;
    }
  
  vtkKWMultiColumnList *filelist = this->FileList->GetWidget();
  int numRows = filelist->GetNumberOfRows();
  vtksys_stl::string shortname = 
    vtksys::SystemTools::GetFilenameName(filename);
  for(int i=0; i<numRows; i++)
    {
    if (!strcmp(this->GetCellText(i, 0), shortname.c_str()))
      {
      filelist->SelectRow(i);
      break;
      }
    }
}

//----------------------------------------------------------------------------
char * vtkKWFileListTable::GetRealNameStringCallback(
  const char* celltext)
{
  if (celltext && strlen(celltext)>0)
    {
    static char newstr[256];
    strcpy(newstr, ++celltext);
    return newstr;
    }
  return NULL;
}

//----------------------------------------------------------------------------
char * vtkKWFileListTable::GetFormatSizeStringCallback(
  const char* celltext)
{
  if (celltext && strlen(celltext)>0)
    {
    unsigned int u;
    sscanf(celltext, "%lu", &u);
    if (u>0)
      {
      // determine thousands separator
      if ( this->Internals->Num_thousands_sep == '\0' ) 
        {
        struct lconv *current_locale = localeconv();
        // if the locale defines thousands_sep 
        if ( current_locale->thousands_sep 
          && *current_locale->thousands_sep) 
          {
          // copy the thousands separator. 
          this->Internals->Num_thousands_sep = 
            *(current_locale->thousands_sep);
          }
        else 
          {
          // default is the comma
          this->Internals->Num_thousands_sep = ',';
          }
        }

      char buffer[50];
      sprintf(buffer, "%d", 
        vtkMath::Round(ceil((double)(u-1)/1024)));
      //put in the thousand sep if necessary  
      vtksys_stl::string outStr = buffer;
      vtksys_stl::string tmpStr = buffer;
      while(tmpStr.size() > 3)
        {
        outStr.insert(tmpStr.size()-3, 1, 
          this->Internals->Num_thousands_sep);
        tmpStr = tmpStr.substr(0,tmpStr.size()-3);
        }
      static char newStr[64];
      sprintf(newStr, "%s KB", outStr.c_str());
      return newStr;
      }
    }
  return NULL;
}
//----------------------------------------------------------------------------
int vtkKWFileListTable::SortTimeCallback(
  const char* celltext1,
  const char* celltext2)
{
  int num1 = atoi(celltext1);
  int num2 = atoi(celltext2);
  
  if (num1 == num2)
    {
    return 0;
    }
    
  if (num1<0 && num2<0)
    {
    return (num1>num2 ? -1: 1);
    }
  
  return (num1>num2 ? 1: -1);
}

//----------------------------------------------------------------------------
char * vtkKWFileListTable::GetFormatTimeStringCallback(
  const char* celltext)
{
  if (celltext && strlen(celltext)>0)
    {
    time_t t=0;
    sscanf(++celltext, "%lu", &t);
    struct tm *new_time = localtime(&t);
    static char buffer[100];
    strftime(buffer, 100, "%c", new_time); 
    return buffer;
    }
  return NULL;
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::FileDoubleClickCallback()
{
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows()>0)
    {
    int selrows = this->FileList->GetWidget()->GetNumberOfSelectedRows();
    int *indices = new int [selrows];
    int nb_selected_rows = this->FileList->GetWidget()->
      GetSelectedRows(indices);
    vtksys_stl::string fullname = this->GetParentDirectory();

    if (!fullname.empty())
      {
      vtksys_stl::string filename = this->GetCellText(indices[0], 0);
      if (strcmp(fullname.c_str(), KWFileBrowser_UNIX_ROOT_DIRECTORY)!=0)
        {
        fullname += KWFileBrowser_PATH_SEPARATOR;
        }
      fullname.append(filename.c_str());
      this->InvokeFileDoubleClickedCommand(fullname.c_str());
      }
    delete [] indices;
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SelectedFileChangedCallback()
{
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows()>0)
    {
    int selrows = this->FileList->GetWidget()->GetNumberOfSelectedRows();
    int *indices = new int [selrows];
    int nb_selected_rows = this->FileList->GetWidget()->
                           GetSelectedRows(indices);
    if (nb_selected_rows>0)
      {
      this->SetSelectedFile(this->GetRowFileName(indices[0]));
      }
    else
      {
      this->SetSelectedFile(NULL);
      }
    delete [] indices;
    }
  else
    {
    this->SetSelectedFile(NULL);
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::KeyHomeEndNavigationCallback(
  const char *key)
{
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows() > 0
     && key && *key)
    {
    ostrstream tk_cmd;
    const char* name = this->FileList->GetWidget()->GetWidgetName();
    if (strcmp(key, "Home")==0)
      {
      tk_cmd << "tablelist::changeSelection " << name 
             << " [tablelist::firstVisibleRow "
             << name << "] -1" << endl;
      }
    else if (strcmp(key, "End")==0)
      {
      tk_cmd << "tablelist::changeSelection " << name 
             << " [tablelist::lastVisibleRow "
             << name << "] -1" << endl;
      }
    tk_cmd << ends;
    this->Script(tk_cmd.str());
    tk_cmd.rdbuf()->freeze(0);
    }
}

//----------------------------------------------------------------------------
//Reference: proc tablelist::yviewSubCmd {win argList} -- in tablelistBind.tcl
//           proc tablelist::autoScan win 
void vtkKWFileListTable::KeyPriorNextNavigationCallback(
  const char *w, int x, int y, 
  int root_x, int root_y, const char* key)
{
  if (this->IsCreated() && key && *key)
    {
    ostrstream tk_cmd;
    const char* widgetname = this->FileList->GetWidget()->GetWidgetName();

    tk_cmd << "upvar #0 ::tablelist::ns" 
           << widgetname<< "::data data" << endl;
    
    tk_cmd << "set w $data(body)" << endl;

    //Figure out how many units in each page
    tk_cmd << "set btmY [expr {[winfo height $w] - 1}]" << endl;
    tk_cmd << "set topRow [expr {int([$w index @0,0]) - 1}]" << endl;
    tk_cmd << "set btmRow [expr {int([$w index @0,$btmY]) - 1}]" << endl;
    
    tk_cmd << "set cur_selrow [lindex [" 
           << widgetname << " curselection] 0]" << endl;
    tk_cmd << "set toScroll 0" << endl;
    
    if (strcmp(key, "Prior")==0)
      {
      tk_cmd << "if { $cur_selrow > $topRow } {" << endl;
        tk_cmd << " set row_index $topRow" << endl;
      tk_cmd << "} else {" << endl;   
        tk_cmd << " set toScroll 1" << endl;
      tk_cmd << " }" << endl;
      }
    else // <Next>
      {
      tk_cmd << "if { $cur_selrow < [expr {$btmRow -1}] } {" << endl;
        tk_cmd << " set row_index [expr {$btmRow}]" << endl;
      tk_cmd << "} else {" << endl;   
        tk_cmd << " set toScroll 1" << endl;
        //tk_cmd << "$w yview scroll 1 pages" << endl;
      tk_cmd << " }" << endl;
      }
    
    tk_cmd << "if { $toScroll == 1 } {" << endl;   
      tk_cmd << "set curNonHiddenCount [tablelist::getNonHiddenRowCount "
             << widgetname 
             << " 0 $cur_selrow]" << endl;
             
      tk_cmd << "set winNonHiddenCount [tablelist::getNonHiddenRowCount "
             << widgetname << " $topRow $btmRow]" << endl;
      tk_cmd << "set delta [expr {$winNonHiddenCount - 1}]" << endl;
      
      if (strcmp(key, "Prior")==0)
        {
        tk_cmd << "set delta [expr {(-1)*$delta}]" << endl;
        }
      else
        {
        tk_cmd << "set delta 0" << endl;
        }

      // Scroll the window  
      tk_cmd << "set offset [expr {$curNonHiddenCount + $delta}]" << endl;
      
      tk_cmd << "set row_index [tablelist::nonHiddenRowOffsetToRowIndex "
             << widgetname << " $offset]" << endl;

      if (strcmp(key, "Next")==0)
        {
        tk_cmd << "set row_index [expr {$row_index - 2}]" << endl;
        }
      
      tk_cmd << "$w yview $row_index" << endl;
      
      tk_cmd << "set btmY [expr {[winfo height $w] - 1}]" << endl;
      tk_cmd << "set topRow [expr {int([$w index @0,0]) - 1}]" << endl;
      tk_cmd << "set btmRow [expr {int([$w index @0,$btmY]) - 1}]" << endl;
      if (strcmp(key, "Prior")==0)
        {
        tk_cmd << "set row_index $topRow" << endl;
        }
      else 
        {
        tk_cmd << "set row_index $btmRow" << endl;
        }      
    tk_cmd << " }" << endl;
    
    // Set selection   
    tk_cmd << "tablelist::changeSelection " << widgetname
           << " $row_index -1" << endl;
     
    tk_cmd << ends;
    this->Script(tk_cmd.str());
    tk_cmd.rdbuf()->freeze(0);
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::RightClickExploreCallback()
{
#ifdef _WIN32
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows()>0)
    {
      if (vtksys::SystemTools::FileIsDirectory(
        this->GetSelectedFile()))
        {
        this->GetApplication()->OpenLink(
          this->GetSelectedFile());
        }
    }
#endif
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::FocusInCallback()
{
  if (this->FileList->GetWidget()->GetNumberOfRows() > 0 &&
    this->FileList->GetWidget()->GetNumberOfSelectedRows()<=0)
    {
    this->FileList->GetWidget()->SelectRow(0);
    }
}

//----------------------------------------------------------------------------
int vtkKWFileListTable::RenameCallback()
{
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows()>0)
    {
    int selrows = this->FileList->GetWidget()->GetNumberOfSelectedRows();
    // Prompt the user for confirmation
    vtksys_stl::string parentdir = this->GetParentDirectory();
    
    vtkDirectory *dir = vtkDirectory::New();
    if (!dir->Open(parentdir.c_str()))
      {
      dir->Delete();
      vtkKWMessageDialog::PopupMessage(
        this->GetApplication(), this, 
        ks_("File Browser|Title|Error!"),
        k_("The parent directory can't be opened."), 
        vtkKWMessageDialog::ErrorIcon | 
        vtkKWMessageDialog::InvokeAtPointer);
      return 0;
      }
    // Prompt the user for the name of the folder  
    vtkKWSimpleEntryDialog *dlg = vtkKWSimpleEntryDialog::New();
    dlg->SetParent(this);
    dlg->SetMasterWindow(this->GetParentTopLevel());
    dlg->SetDisplayPositionToPointer();
    dlg->SetTitle(
      ks_("File Browser|Dialog|Title|Rename file"));
    dlg->SetStyleToOkCancel();
    dlg->Create();
    dlg->GetEntry()->GetLabel()->SetText(
      ks_("File Browser|Dialog|File name:"));
    dlg->GetEntry()->GetWidget()->SetValue(
      vtksys::SystemTools::GetFilenameName(
       this->GetSelectedFile()).c_str());
    dlg->SetText(
      ks_("File Browser|Dialog|Enter a new name for this file"));
    
    dlg->GetEntry()->GetWidget()->SetBinding("<Return>", dlg, "OK");
    dlg->GetOKButton()->SetBinding("<Return>", dlg, "OK");
    dlg->GetCancelButton()->SetBinding("<Return>", dlg, "Cancel");

    vtksys_stl::string newname;
    int ok = dlg->Invoke();
    if (ok)
      {
      newname = dlg->GetEntry()->GetWidget()->GetValue();
      if (newname.empty() || strcmp(newname.c_str(), "")==0 ||
          strcmp(newname.c_str(), ".")==0 ||
          strcmp(newname.c_str(), "..")==0)
        {
        vtkKWMessageDialog::PopupMessage(
          this->GetApplication(), this, 
          ks_("File Browser|Title|Error!"),
          "You must enter a valid file name!", 
          vtkKWMessageDialog::ErrorIcon | 
          vtkKWMessageDialog::InvokeAtPointer);
        dlg->Delete();
        dir->Delete();
        return 0;
        }
      dlg->Delete();
      }
    else
      {
      dir->Delete();
      dlg->Delete();
      return 0;
      }    
    
    vtksys_stl::string filename, fullname;
    // Check if the file is already created
    for (int i = 0; i < dir->GetNumberOfFiles(); i++)
      {
      filename = dir->GetFile(i);
      if (strcmp(filename.c_str(), newname.c_str())==0)
        {
        vtkKWMessageDialog::PopupMessage(
          this->GetApplication(), this, 
          ks_("File Browser|Title|Error!"),
          k_("The file already exists."), 
          vtkKWMessageDialog::ErrorIcon | 
          vtkKWMessageDialog::InvokeAtPointer);
        dir->Delete();
        return 0;
        }
      }
      
    dir->Delete();
    //Rename the selected file
    if (strcmp(parentdir.c_str(), KWFileBrowser_UNIX_ROOT_DIRECTORY)!=0)
      {
      parentdir += KWFileBrowser_PATH_SEPARATOR;
      }
    fullname = parentdir + newname;
    vtksys_stl::string oldfile = this->GetSelectedFile();
    if (rename(this->GetSelectedFile(), fullname.c_str())==0)
      {
      int *indices = new int [selrows];
      int nb_selected_rows = this->FileList->GetWidget()->
                             GetSelectedRows(indices);

      this->SetSelectedFile(fullname.c_str());
      // setup prefix for display
      vtksys_stl::string text;
      if (!vtksys::SystemTools::FileIsDirectory(fullname.c_str()))
        {
        text = "b";
        }
      else
        {
        text = "a";
        }
      this->FileList->GetWidget()->SetCellText(indices[0], 0, 
        text.append(newname.c_str()).c_str());
      this->InvokeFileRenamedCommand(oldfile.c_str(), fullname.c_str());
      delete [] indices;
      
      return 1;
      }
    else
      {
      vtkKWMessageDialog::PopupMessage(
        this->GetApplication(), this, 
        ks_("File Browser|Title|Error!"),
        "The file name can not be changed!", 
        vtkKWMessageDialog::ErrorIcon | 
        vtkKWMessageDialog::InvokeAtPointer);
      }
    }
  return 0;
}

//----------------------------------------------------------------------------
int vtkKWFileListTable::RemoveSelectedFileCallback()
{
  if (this->FileList->GetWidget()->GetNumberOfSelectedRows()>0)
    {
    int selrows = this->FileList->GetWidget()->GetNumberOfSelectedRows();
    // Prompt the user for confirmation
    if (vtkKWMessageDialog::PopupYesNo( 
      this->GetApplication(), 
      this, 
      ks_("File Browser|Title|Delete file"),
      k_("Are you sure you want to delete the selected file?"), 
      vtkKWMessageDialog::WarningIcon | 
      vtkKWMessageDialog::InvokeAtPointer))
      {
      int *indices = new int [selrows];
      int nb_selected_rows = this->FileList->GetWidget()->
        GetSelectedRows(indices);
      vtksys_stl::string fullname = this->GetParentDirectory();

      if (!fullname.empty())
        {
        vtksys_stl::string filename = this->GetCellText(indices[0], 0);
        if (strcmp(fullname.c_str(), KWFileBrowser_UNIX_ROOT_DIRECTORY)!=0)
          {
          fullname += KWFileBrowser_PATH_SEPARATOR;
          }
        fullname.append(filename.c_str());
        int isDir = 0;
        if (vtksys::SystemTools::FileIsDirectory(fullname.c_str()))
          {
          if (!vtksys::SystemTools::RemoveADirectory(fullname.c_str()))
            {
            vtkKWMessageDialog::PopupMessage(
              this->GetApplication(), this, 
              ks_("File Browser|Title|Error!"),
              "The directory can not be removed!", 
              vtkKWMessageDialog::ErrorIcon | 
              vtkKWMessageDialog::InvokeAtPointer);
            delete[] indices;
            return 0;
            }
          isDir = 1;
          }
        else if (vtksys::SystemTools::FileExists(fullname.c_str()))
          {
          if (!vtksys::SystemTools::RemoveFile(fullname.c_str()))
            {
            vtkKWMessageDialog::PopupMessage(
              this->GetApplication(), this, 
              ks_("File Browser|Title|Error!"),
              "The file can not be removed!", 
              vtkKWMessageDialog::ErrorIcon | 
              vtkKWMessageDialog::InvokeAtPointer);
            delete[] indices;
            return 0;
            }
          isDir = 0;
          }
        this->FileList->GetWidget()->DeleteRow(indices[0]);
        int numrows = this->FileList->GetWidget()->GetNumberOfRows();
        if ( numrows > 0)
         {
         this->FileList->GetWidget()->ClearSelection();
         if (indices[0] >= numrows)
           {
           this->FileList->GetWidget()->SelectRow(numrows - 1);
           }
         else
           {
           this->FileList->GetWidget()->SelectRow(indices[0]);
           }
         }
        this->InvokeFileRemovedCommand(fullname.c_str(), isDir);
        }
      else
        {
        delete [] indices;
        return 0;
        }
      delete [] indices;
      return 1;
      }
    }
  return 0;
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetFileSelectedCommand(
  vtkObject *object, const char *method)
{
  this->SetObjectMethodCommand(&this->FileSelectedCommand, object, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::InvokeFileSelectedCommand(const char* path)
{
  if (this->FileSelectedCommand && *this->FileSelectedCommand)
    {
    this->Script("%s \"%s\"", this->FileSelectedCommand, 
      vtksys::SystemTools::EscapeChars(path, 
       KWFileBrowser_ESCAPE_CHARS).c_str());
    }

  this->InvokeEvent(
    vtkKWFileListTable::FileSelectionChangedEvent, (void*)path);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetFileRemovedCommand(
  vtkObject *object, const char *method)
{
  this->SetObjectMethodCommand(&this->FileRemovedCommand, object, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::InvokeFileRemovedCommand(
  const char* path, int isDir)
{
  if (this->FileRemovedCommand && *this->FileRemovedCommand)
    {
    this->Script("%s \"%s\" %d", this->FileRemovedCommand, 
      vtksys::SystemTools::EscapeChars(path, 
       KWFileBrowser_ESCAPE_CHARS).c_str(), isDir);
    }

  this->InvokeEvent(
    vtkKWFileListTable::FileRemovedEvent, (void*)path);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetFileDoubleClickedCommand(
  vtkObject *object, const char *method)
{
  this->SetObjectMethodCommand(&this->FileDoubleClickedCommand, object, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::InvokeFileDoubleClickedCommand(const char* path)
{
  if (this->FileDoubleClickedCommand && *this->FileDoubleClickedCommand)
    {
    this->Script("%s \"%s\"", this->FileDoubleClickedCommand, 
      vtksys::SystemTools::EscapeChars(path, 
       KWFileBrowser_ESCAPE_CHARS).c_str());
    }
  this->InvokeEvent(
    vtkKWFileListTable::FileDoubleClickedEvent, (void*)path);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetFileRenamedCommand(
  vtkObject *object, const char *method)
{
  this->SetObjectMethodCommand(&this->FileRenamedCommand, object, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::InvokeFileRenamedCommand(const char* oldname,
                                                  const char* newname)
{
  if (this->FileRenamedCommand && *this->FileRenamedCommand)
    {
    this->Script("%s \"%s\" \"%s\"", this->FileRenamedCommand, 
      vtksys::SystemTools::EscapeChars(oldname, 
       KWFileBrowser_ESCAPE_CHARS).c_str(), 
       vtksys::SystemTools::EscapeChars(newname, 
       KWFileBrowser_ESCAPE_CHARS).c_str());
    }

  this->InvokeEvent(
    vtkKWFileListTable::FileRenamedEvent, (void*)oldname);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::SetFolderCreatedCommand(
  vtkObject *object, const char *method)
{
  this->SetObjectMethodCommand(&this->FolderCreatedCommand, object, method);
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::InvokeFolderCreatedCommand(const char* filename)
{
  if (this->FolderCreatedCommand && *this->FolderCreatedCommand)
    {
    this->Script("%s \"%s\"", this->FolderCreatedCommand, 
      vtksys::SystemTools::EscapeChars(filename, 
       KWFileBrowser_ESCAPE_CHARS).c_str());
    }
  this->InvokeEvent(
    vtkKWFileListTable::FolderCreatedCommand, (void*)filename);
}

//---------------------------------------------------------------------------
void vtkKWFileListTable::FileRightClickCallback(
  int row, int vtkNotUsed(col), int x, int y)
{
  if (!this->IsCreated())
    {
    return;
    }

  if (!this->ContextMenu)
    {
    this->ContextMenu = vtkKWMenu::New();
    }
  if (!this->ContextMenu->IsCreated())
    {
    this->ContextMenu->SetParent(this->FileList->GetWidget());
    this->ContextMenu->Create();
    }
  this->ContextMenu->DeleteAllItems();

  // if there is no row clicked, popup context menu with new folder
  if (row < 0 || this->FileList->GetWidget()->GetNumberOfRows() <= 0)
    {
    this->PopulateFileContextMenu(1, 0);
    }
  else
    {
    int num_sel = this->FileList->GetWidget()->
      GetNumberOfSelectedRows();
    if (num_sel<=0)
      {
      this->FileList->GetWidget()->SelectRow(row);
      }
    else
      {
      int* indices = new int[num_sel];
      this->FileList->GetWidget()->GetSelectedRows(indices);
      if (indices[0] != row)
        {
        this->FileList->GetWidget()->ClearSelection();
        this->FileList->GetWidget()->SelectRow(row);
        }
      delete [] indices;
      }
    this->PopulateFileContextMenu(1, 1);
    }

  if (this->ContextMenu->GetNumberOfItems())
    {
    this->ContextMenu->PopUp(x, y);
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::CreateNewFolderCallback(
  const char* parentdir)
{
  if (!parentdir || !(*parentdir))
    {
    return;
    }
 
  vtksys_stl::string selfile = parentdir;
  vtkKWMultiColumnList *filelist = this->FileList->GetWidget();
  if (!vtksys::SystemTools::FileIsDirectory(selfile.c_str()))
    {
    vtkKWMessageDialog::PopupMessage(
      this->GetApplication(), this, 
      ks_("File Browser|Title|Error!"),
      k_("Please select a directory first."), 
      vtkKWMessageDialog::ErrorIcon | 
      vtkKWMessageDialog::InvokeAtPointer);
    return;
    }
  
  
  vtkDirectory *dir = vtkDirectory::New();
  if (!dir->Open(selfile.c_str()))
    {
    dir->Delete();
    vtkKWMessageDialog::PopupMessage(
      this->GetApplication(), this, 
      ks_("File Browser|Title|Error!"),
      k_("The selected directory can't be opened."), 
      vtkKWMessageDialog::ErrorIcon | 
      vtkKWMessageDialog::InvokeAtPointer);
    return;
    }
  // Prompt the user for the name of the folder  
  vtkKWSimpleEntryDialog *dlg = vtkKWSimpleEntryDialog::New();
  dlg->SetParent(this);
  dlg->SetMasterWindow(this->GetParentTopLevel());
  dlg->SetDisplayPositionToPointer();
  dlg->SetTitle(
    ks_("File Browser|Dialog|Title|Create new folder"));
  dlg->SetStyleToOkCancel();
  dlg->Create();
  dlg->GetEntry()->GetLabel()->SetText(
    ks_("File Browser|Dialog|Folder name:"));
  dlg->SetText(
    ks_("File Browser|Dialog|Enter a name for this new folder"));
  
  dlg->GetEntry()->GetWidget()->SetBinding("<Return>", dlg, "OK");
  dlg->GetOKButton()->SetBinding("<Return>", dlg, "OK");
  dlg->GetCancelButton()->SetBinding("<Return>", dlg, "Cancel");

  vtksys_stl::string foldername;
  int ok = dlg->Invoke();
  if (ok)
    {
    foldername = dlg->GetEntry()->GetWidget()->GetValue();
    if (foldername.empty() || strcmp(foldername.c_str(), ".")==0 ||
      strcmp(foldername.c_str(), "..")==0)
      {
      vtkKWMessageDialog::PopupMessage(
        this->GetApplication(), this, 
        ks_("File Browser|Title|Error!"),
        "You must enter a valid folder name!", 
        vtkKWMessageDialog::ErrorIcon | 
        vtkKWMessageDialog::InvokeAtPointer);
      dlg->Delete();
      dir->Delete();
      return;
      }
    dlg->Delete();
    }
  else
    {
    dir->Delete();
    dlg->Delete();
    return;
    }    
  
  vtksys_stl::string filename, fullname;
  // Check if the folder is already created
  for (int i = 0; i < dir->GetNumberOfFiles(); i++)
    {
    filename = dir->GetFile(i);
    if (strcmp(filename.c_str(), foldername.c_str())==0)
      {
      vtkKWMessageDialog::PopupMessage(
        this->GetApplication(), this, 
        ks_("File Browser|Title|Error!"),
        k_("The folder name already exists."), 
        vtkKWMessageDialog::ErrorIcon | 
        vtkKWMessageDialog::InvokeAtPointer);
      dir->Delete();
      return;
      }
    }
    
  //Add the new folder
  fullname = selfile + KWFileBrowser_PATH_SEPARATOR + foldername;
  
  if (!dir->MakeDirectory(fullname.c_str()))
    {
    vtkKWMessageDialog::PopupMessage(
      this->GetApplication(), this, 
      ks_("File Browser|Title|Error!"),
      k_("The new directory can not be created."), 
      vtkKWMessageDialog::ErrorIcon | 
      vtkKWMessageDialog::InvokeAtPointer);
    dir->Delete();
    return;
    }
  
  dir->Delete();
  if (vtksys::SystemTools::ComparePath(selfile.c_str(),
    this->GetParentDirectory()))
    {
    this->InvokeFolderCreatedCommand(selfile.c_str());
    }
  else
    {
    this->InvokeFileDoubleClickedCommand(selfile.c_str());
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::PopulateFileContextMenu(
  int enable, int rowselected)
{
  char command[256];
  const char* callback = "CreateNewFolderCallback";
  const char* text = "Create new folder";
  if (!rowselected)
    {
    sprintf(command, "%s \"%s\"", callback,
      vtksys::SystemTools::EscapeChars(
      this->GetParentDirectory(), 
      KWFileBrowser_ESCAPE_CHARS).c_str());
    this->ContextMenu->AddCommand(text, this, command);
    }
  else if (vtksys::SystemTools::FileIsDirectory(
    this->GetSelectedFile()))
    {
    sprintf(command, "%s \"%s\"", callback,
      vtksys::SystemTools::EscapeChars(
      this->GetSelectedFile(), 
      KWFileBrowser_ESCAPE_CHARS).c_str());
    this->ContextMenu->AddCommand(text, this, command);
    }

  if (rowselected)
    {
    #ifdef _WIN32
      if (vtksys::SystemTools::FileIsDirectory(
        this->GetSelectedFile()))
        {
        this->ContextMenu->AddCommand("Explore", this, 
          "RightClickExploreCallback");
       }
    #endif
   // Rename file
    int index = this->ContextMenu->AddCommand("Rename", this, 
      "RenameCallback");
    this->ContextMenu->SetItemAccelerator(index, "F2");
    this->ContextMenu->SetBindingForItemAccelerator(index, 
      this->ContextMenu->GetParent());

    // Delete file
    this->ContextMenu->AddCommand("Delete", this, 
      "RemoveSelectedFileCallback");
    }
  
  if (!enable)
    {
    this->ContextMenu->EnabledOff();
    }
}

//----------------------------------------------------------------------------
void vtkKWFileListTable::PrintSelf(ostream& os, vtkIndent indent)
{
  this->Superclass::PrintSelf(os,indent);
  os << indent << "SelectedFile: " 
     << (this->SelectedFile?this->SelectedFile:"none") 
     << endl;
  os << indent << "ParentDirectory: " 
     << (this->ParentDirectory?this->ParentDirectory:"none") 
     << endl;
  os << indent << "FileSelectedCommand: " 
     << (this->FileSelectedCommand?this->FileSelectedCommand:"none") 
     << endl;
  os << indent << "FileDoubleClickedCommand: " 
     << (this->FileDoubleClickedCommand?this->FileDoubleClickedCommand:"none") 
     << endl;
  os << indent << "FileRemovedCommand: " 
     << (this->FileRemovedCommand?this->FileRemovedCommand:"none") 
     << endl;
  os << indent << "FileRenamedCommand: " 
     << (this->FileRenamedCommand?this->FileRenamedCommand:"none") 
     << endl;
}
